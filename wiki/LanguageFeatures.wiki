#summary Traceur Language Features

= Language Features =

  * [LanguageFeatures#Classes classes] - _Strawman_
  * [LanguageFeatures#Traits traits] - _Strawman_
  * [http://wiki.ecmascript.org/doku.php?id=harmony:modules modules] (in progress)
  * [http://wiki.ecmascript.org/doku.php?id=harmony:iterators iterators]/ for each
  * [http://wiki.ecmascript.org/doku.php?id=harmony:generators generators]
  * [http://wiki.ecmascript.org/doku.php?id=strawman:deferred_functions deferred functions] - _Strawman_
  * [http://wiki.ecmascript.org/doku.php?id=harmony:block_scoped_bindings block scoped bindings]
  * [http://wiki.ecmascript.org/doku.php?id=harmony:destructuring destructuring assignment]
  * [LanguageFeatures#Default_Parameters default parameters]
  * [LanguageFeatures#Rest_Parameters rest parameters]
  * [LanguageFeatures#Spread_Operator spread operator]


== Classes ==

[http://en.wikipedia.org/wiki/Class_(computer_programming) Classes] are a great way to reuse code. Several JS libraries provide classes and inheritance, but they aren't mutually compatible. Our implementation is inspired by Allen Wirfs-Brock's [http://wiki.ecmascript.org/doku.php?id=strawman:obj_initialiser_class_abstraction class initializers proposal]. Here's an example taken from slides to a presentation:
{{{
class SlideParts {
  new(slideEl) {
    // fields:
    this.slideEl = slideEl;
    this.currentPartIndex = -1;
    this.partDetails = [];
    this.init();
  }

  // methods:
  function init() { /*...*/ }
  function comingFromPrev() { /*...*/ }
  function comingFromNext() { /*...*/ }
  function next() { /*...*/ }
  function prev() { /*...*/ }
}
}}}

Here's an example of subclassing an HTML button:
{{{
class CustomButton : HTMLButtonElement {
  new() {
    this.value = 'Custom Button';
  }
}
var button = new CustomButton();
document.body.appendChild(button);
}}}

== Traits ==

Sometimes you want to create a reusable chunk of code that you can use in your classes. Traits make it easy to group methods together as a unit, and mix this unit into one or more classes, merging the features of the trait into the class. Traits are similar to multiple inheritance and mixins from other languages, but they're more robust because name clashes must be resolved explicitly by composers, and because trait composition is order-independent (hence more declarative).

Our implementation is inspired by http://traitsjs.org/ and  [http://wiki.ecmascript.org/doku.php?id=strawman:classes_with_trait_composition classes with trait composition].

The syntax is still evolving but right now it looks like this:
{{{
trait ComparableTrait {
  requires lessThan; // this.lessThan(other) -> boolean
  requires equals; // this.equals(other) -> boolean

  function lessThanOrEquals(other) {
    return this.lessThan(other) || this.equals(other);
  }
  function greaterThan(other) {
    return other.lessThan(this);
  }
  function greaterThanOrEquals(other) {
    return other.lessThan(this) || this.equals(other);
  }
  function notEquals(other) {
    return !(this.equals(other));
  }
}

class Interval {
  mixin ComparableTrait;

  new(min, max) {
    this.start = min;
    this.end = max;
    this.size = max - min - 1;
  }
  function lessThan(ival) {
    return this.end <= ival.start;
  }
  function equals(ival) {
    return this.start == ival.start && this.end == ival.end;
  }
}

var i1 = new Interval(0, 5);
var i2 = new Interval(7, 12);
alert('' + i1 + ' == ' + i2 + ': ' + i1.equals(i2)); // false
alert('' + i1 + ' < ' + i2 + ': ' + i1.lessThan(i2)); // true
}}}


== Default Parameters ==

[http://wiki.ecmascript.org/doku.php?id=harmony:parameter_default_values default parameters] allow your functions to have optional arguments without needing to check `arguments.length` or check for `undefined`.

{{{
function slice(list, indexA = 0, indexB = list.length) {
  // ... 
}
}}}

== Rest Parameters ==

[http://wiki.ecmascript.org/doku.php?id=harmony:rest_parameters Rest parameters] allows your functions to have variable number of arguments without using the `arguments` object.

{{{
function push(array, ...items) {
  items.forEach(function(item) {
    array.push(item);
  });
}
}}}

The rest parameter is an instance of `Array` so all the array methods just works.

== Spread Operator ==

The [http://wiki.ecmascript.org/doku.php?id=harmony:spread spread operator] is like the reverse of [LanguageFeatures#Rest_Parameters rest parameters]. It allows you to expand an array into multiple formal parameters.

{{{
function printf(format, ...parameters) {
  // ...
}

function push(array, ...items) {
  array.push(...items);
}

function add(x, y) {
  return x + y;
}

var numbers = [4, 38];
add(...numbers);  // 42
}}}

The spread operator also works in array literals which allows you to combine multiple arrays more easily.

{{{
var a = [1];
var b = [2, 3, 4];
var c = [6, 7];
var d = [0, ...a, ...b, 5, ...c];
}}} 